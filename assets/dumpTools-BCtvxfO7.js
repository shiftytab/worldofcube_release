const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-BmJPcCdY.js","assets/index-XcJlsfGO.css","assets/pass.fragment-DmVCsv5H.js"])))=>i.map(i=>d[i]);
import{C as T,T as d,e as E,u as D}from"./index-BmJPcCdY.js";import{E as S,a as x}from"./passPostProcess-WgEmDRM-.js";let l,u=null;async function R(){return u||(u=new Promise((a,s)=>{let n,e=null;const f={preserveDrawingBuffer:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1};E(async()=>{const{ThinEngine:i}=await import("./index-BmJPcCdY.js").then(o=>o.v);return{ThinEngine:i}},__vite__mapDeps([0,1])).then(({ThinEngine:i})=>{try{n=new OffscreenCanvas(100,100),e=new i(n,!1,f)}catch{n=document.createElement("canvas"),e=new i(n,!1,f)}D.Instances.pop(),D.OnEnginesDisposedObservable.add(t=>{e&&t!==e&&!e.isDisposed&&D.Instances.length===0&&y()}),e.getCaps().parallelShaderCompile=void 0;const o=new S(e);E(async()=>{const{passPixelShader:t}=await import("./pass.fragment-DmVCsv5H.js");return{passPixelShader:t}},__vite__mapDeps([2,0,1])).then(({passPixelShader:t})=>{if(!e){s("Engine is not defined");return}const p=new x({engine:e,name:t.name,fragmentShader:t.shader,samplerNames:["textureSampler"]});l={canvas:n,engine:e,renderer:o,wrapper:p},a(l)})}).catch(s)})),await u}async function v(a,s,n,e,f="image/png",i,o){const t=await n.readPixels(0,0,a,s),p=new Uint8Array(t.buffer);w(a,s,p,e,f,i,!0,void 0,o)}function _(a,s,n,e="image/png",f,i=!1,o=!1,t){return new Promise(p=>{w(a,s,n,r=>p(r),e,f,i,o,t)})}function w(a,s,n,e,f="image/png",i,o=!1,t=!1,p){R().then(r=>{if(r.engine.setSize(a,s,!0),n instanceof Float32Array){const m=new Uint8Array(n.length);let c=n.length;for(;c--;){const g=n[c];m[c]=Math.round(T(g)*255)}n=m}const h=r.engine.createRawTexture(n,a,s,5,!1,!o,1);r.renderer.setViewport(),r.renderer.applyEffectWrapper(r.wrapper),r.wrapper.effect._bindTexture("textureSampler",h),r.renderer.draw(),t?d.ToBlob(r.canvas,m=>{const c=new FileReader;c.onload=g=>{const A=g.target.result;e&&e(A)},c.readAsArrayBuffer(m)},f,p):d.EncodeScreenshotCanvasData(r.canvas,e,f,i,p),h.dispose()})}function y(){l?(l.wrapper.dispose(),l.renderer.dispose(),l.engine.dispose()):u==null||u.then(a=>{a.wrapper.dispose(),a.renderer.dispose(),a.engine.dispose()}),u=null,l=null}const I={DumpData:w,DumpDataAsync:_,DumpFramebuffer:v,Dispose:y},b=()=>{d.DumpData=w,d.DumpDataAsync=_,d.DumpFramebuffer=v};b();export{y as Dispose,w as DumpData,_ as DumpDataAsync,v as DumpFramebuffer,I as DumpTools};
